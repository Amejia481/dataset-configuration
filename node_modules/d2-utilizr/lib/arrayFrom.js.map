{"version":3,"sources":["../src/arrayFrom.js"],"names":[],"mappings":";;;;;;;kBAWwB;;;;;;;;;;;;;;;;;AAAT,SAAS,SAAT,CAAmB,KAAnB,EAA0B,QAA1B,EAAoC;AAC/C,QAAI,UAAU,SAAV,OAAU,CAAS,QAAT,EAAmB,KAAnB,EAA0B,GAA1B,EAA+B;AACzC,YAAI,CAAC,QAAD,IAAa,CAAC,SAAS,MAAT,EAAiB;AAC/B,mBAAO,EAAP,CAD+B;SAAnC;;;AADyC,YAMrC,OAAO,QAAP,KAAoB,QAApB,EAA8B;AAC9B,uBAAW,SAAS,KAAT,CAAe,EAAf,CAAX,CAD8B;SAAlC;;AAIA,YAAI,uBAAJ,EAA6B;;AACzB,mBAAO,MAAM,IAAN,CAAW,QAAX,EAAqB,SAAS,CAAT,EAAY,OAAO,SAAS,MAAT,CAA/C,CADyB;SAA7B;;AAIA,YAAI,QAAQ,EAAR;YACA,CADJ;;;AAdyC,aAkBzC,GAAQ,SAAS,CAAT,CAlBiC;AAmBzC,cAAM,MAAO,GAAC,GAAM,CAAN,GAAW,SAAS,MAAT,GAAkB,GAAlB,GAAwB,GAApC,GAA2C,SAAS,MAAT,CAnBf;;AAqBzC,aAAK,IAAI,KAAJ,EAAW,IAAI,GAAJ,EAAS,GAAzB,EAA8B;AAC1B,kBAAM,IAAN,CAAW,SAAS,CAAT,CAAX,EAD0B;SAA9B;;AAIA,eAAO,KAAP,CAzByC;KAA/B,CADiC;;AA6B/C,QAAI,UAAU,SAAV,IAAuB,UAAU,IAAV,EAAgB;AACvC,eAAO,EAAP,CADuC;KAA3C;;AAIA,QAAI,uBAAQ,KAAR,CAAJ,EAAoB;AAChB,eAAO,WAAa,MAAM,SAAN,CAAgB,KAAhB,CAAsB,IAAtB,CAA2B,KAA3B,CAAb,GAAiD,KAAjD,CADS;KAApB;;AAIA,QAAI,cAAc,oDAAd,CArC2C;AAsC/C,QAAI,SAAS,MAAM,MAAN,KAAiB,SAAjB,IAA8B,SAAS,QAAT,KAAsB,SAAS,UAAT,IAAuB,CAAC,MAAM,KAAN,CAArF,EAAmG;;AAEnG,eAAO,QAAQ,KAAR,CAAP,CAFmG;KAAvG;;AAKA,WAAO,CAAC,KAAD,CAAP,CA3C+C;CAApC","file":"arrayFrom.js","sourcesContent":["import isArray from './isArray';\n\n/**\n * Create an array from a value\n *\n * @param {*} param Value to transform to an array\n * @param {boolean} [isNewRef] Should return a new reference than the one from the `param` value\n * @returns {Array} The resulting array\n *\n * @requires isArray\n */\nexport default function arrayFrom(param, isNewRef) {\n    var toArray = function(iterable, start, end) {\n        if (!iterable || !iterable.length) {\n            return [];\n        }\n\n        // FIXME: This will never be called as the if check excludes type string\n        if (typeof iterable === 'string') {\n            iterable = iterable.split('');\n        }\n\n        if (supportsSliceOnNodeList) { // FIXME: This does not exist\n            return slice.call(iterable, start || 0, end || iterable.length);\n        }\n\n        var array = [],\n            i;\n\n        // FIXME: start and end are always 0 and iterable.length\n        start = start || 0;\n        end = end ? ((end < 0) ? iterable.length + end : end) : iterable.length;\n\n        for (i = start; i < end; i++) {\n            array.push(iterable[i]);\n        }\n\n        return array;\n    };\n\n    if (param === undefined || param === null) {\n        return [];\n    }\n\n    if (isArray(param)) {\n        return (isNewRef) ? Array.prototype.slice.call(param) : param;\n    }\n\n    var type = typeof param;\n    if (param && param.length !== undefined && type !== 'string' && (type !== 'function' || !param.apply)) {\n        // TODO: This function call will always fail because of supportsSliceOnNodeList being undefined\n        return toArray(param);\n    }\n\n    return [param];\n}\n"]}